import json
import random

import structlog
from django.apps import apps
from django.db import models
from django.utils import timezone
from sortedm2m.fields import SortedManyToManyField

from siarnaq.api.compete.models import Match, MatchParticipant
from siarnaq.api.episodes import challonge
from siarnaq.api.episodes.managers import EpisodeQuerySet, TournamentQuerySet
from siarnaq.api.teams.models import Team

logger = structlog.get_logger(__name__)


class Language(models.TextChoices):
    """
    An immutable type enumerating the available languages.
    """

    JAVA_8 = "java8"
    PYTHON_3 = "py3"


class EligibilityCriterion(models.Model):
    """
    A database model for an eligibility criterion for entering into a tournament.
    """

    title = models.CharField(max_length=128)
    """The title of this criterion."""

    description = models.TextField()
    """The description of this criterion."""

    icon = models.CharField(max_length=8)
    """An icon to display for teams that satisfy this criterion."""

    def __str__(self):
        return self.title


class Episode(models.Model):
    """
    A database model for the information regarding an episode of Battlecode.
    """

    name_short = models.SlugField(max_length=16, primary_key=True)
    """Short unique identifying tag for the episode."""

    name_long = models.CharField(max_length=128)
    """Full-form name for the episode."""

    blurb = models.TextField(blank=True)
    """A longer description of the episode."""

    registration = models.DateTimeField()
    """
    The time at which registration for the episode begins.
    Before this time, the episode is only visible to staff users.
    """

    game_release = models.DateTimeField()
    """
    The time at which the game specs are released.
    Before this time, the game specs are only visible to staff users.
    """

    game_archive = models.DateTimeField()
    """
    The time at which the episode is archived.
    After this time, no more ranked matches can be played.
    """

    submission_frozen = models.BooleanField(default=True)
    """
    Whether submissions are frozen.
    If true, only teams with staff privileges can make submisssions.
    """

    autoscrim_schedule = models.CharField(max_length=64, null=True, blank=True)
    """A cron specification for the autoscrim schedule, or null if disabled."""

    language = models.CharField(max_length=8, choices=Language.choices)
    """The implementation language supported for this episode."""

    scaffold = models.URLField(blank=True)
    """The URL of the git repository where the scaffold can be obtained."""

    artifact_name = models.CharField(max_length=32, blank=True)
    """The name of the artifact generated by deploy systems."""

    release_version_public = models.CharField(max_length=32, blank=True)
    """The code release available for public use."""

    release_version_saturn = models.CharField(max_length=32, blank=True)
    """The code release used by Saturn, which may differ from the public version."""

    eligibility_criteria = models.ManyToManyField(
        EligibilityCriterion, related_name="episodes", blank=True
    )
    """The eligibility criteria active in this episode."""

    pass_requirement_win = models.PositiveSmallIntegerField(null=True, blank=True)
    """
    The minimum number of matches to be won within a specified window in order to pass
    the Battlecode class.
    """

    pass_requirement_out_of = models.PositiveSmallIntegerField(null=True, blank=True)
    """
    The size of the window in which a minimum number of matches must be won in order to
    pass the Battlecode class.
    """

    objects = EpisodeQuerySet.as_manager()

    def __str__(self):
        return self.name_short

    def frozen(self):
        """Return whether the episode is currently frozen to submissions."""
        now = timezone.now()
        if self.submission_frozen or now < self.game_release:
            return True
        return Tournament.objects.filter(
            episode=self,
            submission_freeze__lte=now,
            submission_unfreeze__gt=now,
            is_public=True,
        ).exists()

    def autoscrim(self, best_of):
        """
        Trigger a round of automatically-generated ranked scrimmages for all teams in
        this episode with an accepted submission, unless the episode is archived or
        frozen.

        Parameters
        ----------
        best_of : int
            The number of maps to be played in each match, must be no greater than the
            number of maps available for the episode.
        """
        log = logger.bind(episode=self.pk)
        if self.frozen():
            log.warn("autoscrim_frozen", message="Refusing to autoscrim: frozen.")
            return
        if timezone.now() > self.game_archive:
            log.warn("autoscrim_archived", message="Refusing to autoscrim: archived.")
        apps.get_model("teams", "Team").objects.autoscrim(episode=self, best_of=best_of)

    def for_saturn(self):
        """Return the representation of this object as expected by Saturn."""
        return {
            "name": self.name_short,
            "language": self.language,
            "scaffold": self.scaffold,
        }


class Map(models.Model):
    """
    A database model for the information regarding a game map in an episode.
    """

    episode = models.ForeignKey(Episode, on_delete=models.CASCADE, related_name="maps")
    """The episode to which this map belongs."""

    name = models.SlugField(max_length=24)
    """The name of the map."""

    is_public = models.BooleanField(default=False)
    """
    Whether the map is publicly accessible.
    If false, only teams with staff privileges can use the map.
    """

    class Meta:
        constraints = [
            models.UniqueConstraint(
                fields=["episode", "name"],
                name="map-unique-episode-name",
            )
        ]

    def __str__(self):
        return f"{self.name} ({self.episode})"


class TournamentStyle(models.TextChoices):
    """
    An immutable type enumerating the available styles of tournament.
    """

    SINGLE_ELIMINATION = "SE"
    DOUBLE_ELIMINATION = "DE"


class Tournament(models.Model):
    """
    A database model for the information regarding a tournament in an episode.
    """

    name_short = models.SlugField(max_length=32, primary_key=True)
    """Short unique identifying tag for the tournament."""

    name_long = models.CharField(max_length=128)
    """Full-form name for the tournament."""

    blurb = models.TextField(blank=True)
    """A longer description of the tournament."""

    episode = models.ForeignKey(
        Episode,
        on_delete=models.PROTECT,
        related_name="tournaments",
    )
    """The episode to which this tournament belongs."""

    style = models.CharField(max_length=2, choices=TournamentStyle.choices)
    """The style of this tournament."""

    eligibility_includes = models.ManyToManyField(
        EligibilityCriterion,
        related_name="include_tournaments",
        blank=True,
    )
    """
    The eligibility criteria that must be satisfied for a team to enter the tournament.
    """

    eligibility_excludes = models.ManyToManyField(
        EligibilityCriterion,
        related_name="exclude_tournaments",
        blank=True,
    )
    """
    The eligibility criteria that must not be satisfied for a team to enter the
    tournament.
    """

    require_resume = models.BooleanField()
    """Whether teams must have submitted resumes in order to enter the tournament."""

    is_public = models.BooleanField()
    """Whether this tournament is included in the public index."""

    submission_freeze = models.DateTimeField()
    """
    The time at which submissions are frozen for the tournament.
    Between this time and the unfreeze time, only staff members are able to submit.
    """

    submission_unfreeze = models.DateTimeField()
    """
    The time at which submissions are unfrozen for the tournament.
    Between the freeze time and this time, only staff members are able to submit.
    The submissions to enter into this tournament are the latest ones accepted by this
    time.
    """

    in_progress = models.BooleanField(default=False)
    """Whether the tournament is currently being run on the Saturn compute cluster."""

    challonge_id_private = models.SlugField(null=True, blank=True)
    """The Challonge ID of the associated private bracket."""

    challonge_id_public = models.SlugField(null=True, blank=True)
    """The Challonge ID of the associated private bracket."""

    # TODO drop the following two fields when ready to make incompatible migrations

    challonge_private = models.URLField(null=True, blank=True)
    """A private Challonge bracket showing matches in progress as they are run."""

    challonge_public = models.URLField(null=True, blank=True)
    """A public Challonge bracket showing match results as they are released."""

    objects = TournamentQuerySet.as_manager()

    def __str__(self):
        return self.name_short

    def get_potential_participants(self):
        """Returns the list of participants that would be entered in this tournament,
        if it were to start right now."""
        # TODO incorporate real eligibility stuff
        return (
            Team.objects.with_active_submission()
            .filter(episode=self.episode)
            .all()
            .order_by("-profile__rating__value")
        )

    def initialize(self):
        """
        Seed the tournament with eligible teams in order of decreasing rating,
        populate the Challonge brackets, and create TournamentRounds.
        """

        tournament_name_public = f"{self.episode.name_long} {self.name_long}"
        tournament_name_private = tournament_name_public + " (private)"

        # For security by obfuscation,
        # and to allow easy regeneration of bracket
        key = random.randint(1000, 9999)
        # Challonge does not allow hyphens in its IDs
        # so substitute them just in case
        tournament_id_public = (
            f"{self.episode.name_short}_{self.name_short}_{key}"
        ).replace("-", "_")
        tournament_id_private = f"{tournament_id_public}_private"

        # TODO support double
        is_single_elim = True
        participants = self.get_potential_participants()
        # Parse into a format Challonge enjoys
        # 1-idx seed
        # Store team id in misc, for convenience (re-looking up is annoying)
        # Store tour submission in misc, for consistency and convenience
        # Note that tour submission should never change during a tournament anyways
        # due to submission freeze. Bad things might happen if it does tho
        participants = [
            {"name": p.name, "seed": idx + 1, "misc": f"{p.id},{p.active_submission}"}
            for (idx, p) in enumerate(participants)
        ]
        print(participants)

        # First bracket made should be private,
        # to hide results and enable fixing accidents
        challonge.create_tour(
            tournament_id_private, tournament_name_private, True, is_single_elim
        )
        challonge.bulk_add_participants(tournament_id_private, participants)
        challonge.start_tour(tournament_id_private)

        tour = json.loads(challonge.get_tour(tournament_id_private))
        # Derive round IDs
        # Takes some wrangling with API response format
        # TODO move this block to challonge.py
        rounds = set()
        for item in tour["included"]:
            if item["type"] == "match":
                round_idx = item["attributes"]["round"]
                if round_idx not in rounds:
                    rounds.add(round_idx)

        # TODO check and tweak iter order in double elim
        round_objects = [
            TournamentRound(
                tournament=self,
                challonge_id=round_idx,
                name=f"{tournament_name_private} Round {round_idx}",
            )
            for round_idx in rounds
        ]
        print(round_objects)
        TournamentRound.objects.bulk_create(round_objects)

        self.challonge_id_private = tournament_id_private
        self.challonge_id_public = tournament_id_public
        self.in_progress = True
        self.save()

    def start_progress(self):
        """Start or resume the tournament."""
        raise NotImplementedError

    def stop_progress(self):
        """Pause the tournament."""
        raise NotImplementedError

    def enqueue_open_matches(self):
        """Find matches that are waiting to be run, and run them."""
        raise NotImplementedError


class ReleaseStatus(models.IntegerChoices):
    """
    An immutable type enumerating the degree to which the results of a tournament match
    are released. Greater values indicate greater visibility.
    """

    HIDDEN = 0
    PARTICIPANTS = 1
    RESULTS = 2


class TournamentRound(models.Model):
    """
    A database model for the information regarding a round of a tournament. A round is
    defined as a parallel set of matches; for example, "Round 1", or the semi-finals.
    """

    tournament = models.ForeignKey(
        Tournament,
        on_delete=models.PROTECT,
        related_name="rounds",
    )
    """The tournament to which this round belongs."""

    # TODO consider renaming this as "challonge_round_number"
    # Should only do this when ready to run back-incompatible migrations
    challonge_id = models.SmallIntegerField(null=True, blank=True)
    """The ID of this round as referenced by Challonge."""

    name = models.CharField(max_length=64)
    """The name of this round in human-readable form, such as "Round 1"."""

    maps = SortedManyToManyField(Map, related_name="tournament_rounds", blank=True)
    """The maps to be used in this round."""

    release_status = models.IntegerField(
        choices=ReleaseStatus.choices, default=ReleaseStatus.HIDDEN
    )
    """THe degree to which matches in this round are released."""

    class Meta:
        constraints = [
            models.UniqueConstraint(
                fields=["tournament", "challonge_id"],
                name="round-unique-tournament-challonge",
            )
        ]

    def __str__(self):
        return f"{self.tournament} ({self.name})"

    def enqueue(self):
        """Creates and enqueues all matches for this round.
        Fails if this round is already in progress."""

        tour = json.loads(challonge.get_tour(self.tournament.challonge_id_private))
        # Derive matches of this round
        matches = []
        # kes some wrangling with API response format
        for item in tour["included"]:
            if item["type"] == "match":
                round_idx = item["attributes"]["round"]
                if round_idx == self.challonge_id:
                    # Only enqueue the round if all matches are ready and open.
                    # TODO create a force-requeue,
                    # which allows for open, but not pending
                    if item["attributes"]["state"] in ("open", "pending"):
                        # TODO return some sort of 400
                        raise Exception
                    matches.add(item)

        # quests),
        #     )
        #     matches = Match.objects.bulk_create(
        #         Match(
        #             episode_id=request.episode_id,
        #             alternate_order=request.determine_is_alternating(),
        #             is_ranked=request.is_ranked,
        #         )
        #         for request in requests
        #     )
        #     MatchParticipant.objects.bulk_create(
        #         MatchParticipant(
        #             team_id=team_id,
        #             submission_id=team_submissions[team_id],
        #             match=match,
        #             player_index=player_index,
        #         )
        #         for request, match in zip(requests, matches)
        #         for player_index, team_id in enumerate(request.determine_order())
        #     )
        #     Match.maps.through.objects.bulk_create(
        #         Match.maps.through(match=match, map=map_obj)
        #         for match, request in zip(matches, requests)
        #         for map_obj in request.maps.all()
        #     )

        # # Send them to Saturn
        # Match.objects.filter(pk__in={match.pk for match in matches}).enqueue()

        match_objects = []
        match_participant_objects = []

        for m in matches:
            match_object = Match(
                episode=self.tournament.episode,
                tournament_round=self,
                maps=self.maps,
                alternate_order=True,
                is_ranked=False,
                challonge_id=m["id"],
            )
            match_participant_1_object = MatchParticipant(
                team_id=team_id,
                submission_id=team_submissions[team_id],
                match=match,
                player_index=player_index,
            )

        match_objects = [
            Match(
                episode=self.tournament.episode,
                tournament_round=self,
                maps=self.maps,
                alternate_order=True,
                is_ranked=False,
                challonge_id=m["id"],
            )
            for m in matches
        ]
        print(match_objects)
        matches = Match.objects.bulk_create(match_objects)
        matches.enqueue()
        print(matches)
